{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to KiloGuide Presentation This guide aims to help you to learn how to use kilobots . It has been created for anyone interested in kilobots and swarm robotics , novice or expert. About Kilobots Kilobots are small, minimalist and cheap robots designed by a team from the university of Harvard. They are equiped with all the necessary components to implement swarm behaviors. Organisation This guide is divided in two sections . The guides aim to explain you basic kilobots operations, such as \"transferring code to the kilobot\", \"calibrating the kilobot\" or \"using Kilo-GUI\". The tutorials focus on the implementation part. With tutorials, you will learn how to code for the kilobot through easy and diverse projects. If you haven't used kilobots yet, you should probably start by reading the getting-started guide . Resources and troubleshooting There are a few important resources available online about kilobots. This guide has been designed has a minimalist introduction to kilobots and swarm robotics. Therefore, if you want to dive deeper in the kilobot universe or have experienced a problem during your learning process, you should check the following websites : The kilobotics website The kilobot library The kilolib source code A \"getting started\" wiki for kilobots Kilobot's user manual The Harvard's Self-Organizing Research Group Repository Authors and contact This guide has been written by Simon Lejoly and is part of a project commanded by the university of Namur . Note This guide is not an official guide from the kilobot team or K-Team. To find appropriate support, please visit the links listed above.","title":"Home"},{"location":"index.html#welcome-to-kiloguide","text":"","title":"Welcome to KiloGuide"},{"location":"index.html#presentation","text":"This guide aims to help you to learn how to use kilobots . It has been created for anyone interested in kilobots and swarm robotics , novice or expert.","title":"Presentation"},{"location":"index.html#about-kilobots","text":"Kilobots are small, minimalist and cheap robots designed by a team from the university of Harvard. They are equiped with all the necessary components to implement swarm behaviors.","title":"About Kilobots"},{"location":"index.html#organisation","text":"This guide is divided in two sections . The guides aim to explain you basic kilobots operations, such as \"transferring code to the kilobot\", \"calibrating the kilobot\" or \"using Kilo-GUI\". The tutorials focus on the implementation part. With tutorials, you will learn how to code for the kilobot through easy and diverse projects. If you haven't used kilobots yet, you should probably start by reading the getting-started guide .","title":"Organisation"},{"location":"index.html#resources-and-troubleshooting","text":"There are a few important resources available online about kilobots. This guide has been designed has a minimalist introduction to kilobots and swarm robotics. Therefore, if you want to dive deeper in the kilobot universe or have experienced a problem during your learning process, you should check the following websites : The kilobotics website The kilobot library The kilolib source code A \"getting started\" wiki for kilobots Kilobot's user manual The Harvard's Self-Organizing Research Group Repository","title":"Resources and troubleshooting"},{"location":"index.html#authors-and-contact","text":"This guide has been written by Simon Lejoly and is part of a project commanded by the university of Namur . Note This guide is not an official guide from the kilobot team or K-Team. To find appropriate support, please visit the links listed above.","title":"Authors and contact"},{"location":"about.html","text":"About Authors and contact This guide has been written by Simon Lejoly and is part of a project commanded by the university of Namur . Licence Some of the content of this guide, including images, may be subject to copyright.","title":"About"},{"location":"about.html#about","text":"","title":"About"},{"location":"about.html#authors-and-contact","text":"This guide has been written by Simon Lejoly and is part of a project commanded by the university of Namur .","title":"Authors and contact"},{"location":"about.html#licence","text":"Some of the content of this guide, including images, may be subject to copyright.","title":"Licence"},{"location":"to-be-implemented.html","text":"This part of the guide hasn't been implemented yet It will surely be added in a future update... Get back to the home page","title":"This part of the guide hasn't been implemented yet"},{"location":"to-be-implemented.html#this-part-of-the-guide-hasnt-been-implemented-yet","text":"","title":"This part of the guide hasn't been implemented yet"},{"location":"to-be-implemented.html#it-will-surely-be-added-in-a-future-update","text":"Get back to the home page","title":"It will surely be added in a future update..."},{"location":"guides/coding-for-kilobots.html","text":"Coding for kilobots Programs for kilobots are coded in C language, then compiled as hex instructions for the kilobot to read. Note If you are not familiar with the C language, your priority should be to learn its basics. Here is a great tutorial to get you started. Default template The default template for the kilobot code looks like this : #include <kilolib.h> void setup() { // Put your setup code here, to be run only once } void loop() { // Put your main code here, to be run repeatedly } int main() { // Initializes hardware kilo_init(); // Starts program kilo_start(setup, loop); return 0; } This code shows the two main parts of a kilobot program : the setup and loop functions. The setup() function is executed only once, at the very start of the execution. It's a great place to put the code that initialize some variables or constants. The loop() function is run repeatedly during the whole execution. It's where the common behavior of the kilobot is implemented. Basic functions Here are some of the most useful functions of the kilolib library : Function Effects kilo_init() Initializes kilobot's hardware kilo_start(setup, loop) Starts the execution of the program RGB(r, g, b) Converts RGB code to a parameter used by set_color() set_color(color) Sets the kilobot's LED color set_motors(left, right) Sets each motor speed, enabling movement delay(millis) Pauses the execution for a given amount of milliseconds","title":"Coding for kilobots"},{"location":"guides/coding-for-kilobots.html#coding-for-kilobots","text":"Programs for kilobots are coded in C language, then compiled as hex instructions for the kilobot to read. Note If you are not familiar with the C language, your priority should be to learn its basics. Here is a great tutorial to get you started.","title":"Coding for kilobots"},{"location":"guides/coding-for-kilobots.html#default-template","text":"The default template for the kilobot code looks like this : #include <kilolib.h> void setup() { // Put your setup code here, to be run only once } void loop() { // Put your main code here, to be run repeatedly } int main() { // Initializes hardware kilo_init(); // Starts program kilo_start(setup, loop); return 0; } This code shows the two main parts of a kilobot program : the setup and loop functions. The setup() function is executed only once, at the very start of the execution. It's a great place to put the code that initialize some variables or constants. The loop() function is run repeatedly during the whole execution. It's where the common behavior of the kilobot is implemented.","title":"Default template"},{"location":"guides/coding-for-kilobots.html#basic-functions","text":"Here are some of the most useful functions of the kilolib library : Function Effects kilo_init() Initializes kilobot's hardware kilo_start(setup, loop) Starts the execution of the program RGB(r, g, b) Converts RGB code to a parameter used by set_color() set_color(color) Sets the kilobot's LED color set_motors(left, right) Sets each motor speed, enabling movement delay(millis) Pauses the execution for a given amount of milliseconds","title":"Basic functions"},{"location":"guides/compile-your-code.html","text":"Compile your code There are many ways to compile code for kilobots. This guide presents two of them. Note The following methods have mostly been tested on MacOS Big Sur . If you experience any problem, please consider visiting this quick-start wiki or this guide from the official website (go to 'advanced use' in the 'documentation' section). Both of those websites where used to write this guide. Compiling your code - the easy way The kilobotics website provides a simple online editor to write code for kilobots. Once logged in with your Dropbox account, you can access the editor, create new programs and save them. To compile your program, just click the green compile button. A .hex file with the same name as your .c file should appear in the KiloEdit directory of your dropbox. Warning Kilobotics' online editor has aged and is not really maintained anymore. Depending on your operating system, browser or dropbox account and configurations, the editor may not work properly. If this is your case, please use the alternative method presented below. Compiling your code - the less-easy way If the kilobotics' online editor doesn't work or doesn't suit your needs, you can still go for the tough method : compiling the code manually. The goal of this tutorial is to get you a simple command-line utility to easily compile your different programs. Warning The following method may not work with Windows operating system. We suggest that Windows users use a virtual machine running Linux. Step 1 : install AVR compilator For Linux using apt Run the following command in the terminal : sudo apt-get install avr-libc gcc-avr avrdude For MacOS using homebrew Run the following command in the terminal : brew tap osx-cross/avr brew install avr-gcc Step 2 : download the template code To get the task simpler, download this file . It contains a shell script that will take care of library dependencies and allow us to compile code with just one command. Step 3 : place your files inside the template directory Place your files inside the 'TemplateForCompiling' directory. They should now be in the same directory as compileCode.sh . Step 4 : compile with one command Open a terminal window and navigate inside the 'TemplateForCompiling' directory with the cd command. Type the following command : ./compileCode.sh your-file Note Replace 'your-file' by the real name of the file you want to compile. Note Note how we didn't put the .c extension at the end of the file name. We are done ! The .hex file corresponding to your program should now appear inside the 'TemplateForCompiling/build/' directory. If anything went wrong, refer to the error message returned by the compileCode.sh script. If your code contains syntaxical errors, they will be listed there.","title":"Compile your code"},{"location":"guides/compile-your-code.html#compile-your-code","text":"There are many ways to compile code for kilobots. This guide presents two of them. Note The following methods have mostly been tested on MacOS Big Sur . If you experience any problem, please consider visiting this quick-start wiki or this guide from the official website (go to 'advanced use' in the 'documentation' section). Both of those websites where used to write this guide.","title":"Compile your code"},{"location":"guides/compile-your-code.html#compiling-your-code-the-easy-way","text":"The kilobotics website provides a simple online editor to write code for kilobots. Once logged in with your Dropbox account, you can access the editor, create new programs and save them. To compile your program, just click the green compile button. A .hex file with the same name as your .c file should appear in the KiloEdit directory of your dropbox. Warning Kilobotics' online editor has aged and is not really maintained anymore. Depending on your operating system, browser or dropbox account and configurations, the editor may not work properly. If this is your case, please use the alternative method presented below.","title":"Compiling your code - the easy way"},{"location":"guides/compile-your-code.html#compiling-your-code-the-less-easy-way","text":"If the kilobotics' online editor doesn't work or doesn't suit your needs, you can still go for the tough method : compiling the code manually. The goal of this tutorial is to get you a simple command-line utility to easily compile your different programs. Warning The following method may not work with Windows operating system. We suggest that Windows users use a virtual machine running Linux.","title":"Compiling your code - the less-easy way"},{"location":"guides/compile-your-code.html#step-1-install-avr-compilator","text":"","title":"Step 1 : install AVR compilator"},{"location":"guides/compile-your-code.html#for-linux-using-apt","text":"Run the following command in the terminal : sudo apt-get install avr-libc gcc-avr avrdude","title":"For Linux using apt"},{"location":"guides/compile-your-code.html#for-macos-using-homebrew","text":"Run the following command in the terminal : brew tap osx-cross/avr brew install avr-gcc","title":"For MacOS using homebrew"},{"location":"guides/compile-your-code.html#step-2-download-the-template-code","text":"To get the task simpler, download this file . It contains a shell script that will take care of library dependencies and allow us to compile code with just one command.","title":"Step 2 : download the template code"},{"location":"guides/compile-your-code.html#step-3-place-your-files-inside-the-template-directory","text":"Place your files inside the 'TemplateForCompiling' directory. They should now be in the same directory as compileCode.sh .","title":"Step 3 : place your files inside the template directory"},{"location":"guides/compile-your-code.html#step-4-compile-with-one-command","text":"Open a terminal window and navigate inside the 'TemplateForCompiling' directory with the cd command. Type the following command : ./compileCode.sh your-file Note Replace 'your-file' by the real name of the file you want to compile. Note Note how we didn't put the .c extension at the end of the file name.","title":"Step 4 : compile with one command"},{"location":"guides/compile-your-code.html#we-are-done","text":"The .hex file corresponding to your program should now appear inside the 'TemplateForCompiling/build/' directory. If anything went wrong, refer to the error message returned by the compileCode.sh script. If your code contains syntaxical errors, they will be listed there.","title":"We are done !"},{"location":"guides/getting-started.html","text":"Getting started with kilobots Here is a simple guide to get started with kilobots. Turning the kilobot on and off On the right side of the front leg are two pins. You probably also have a small red connector for those two pins. By placing the connector on the two pins, you turn the kilobot on and it should blink green. To turn the kilobot off , simply remove the connector. Note As not to lose the connector, you can simply place it on one pin. Warning Be sure not to place the connectors on the two pins that are on the left side of the front leg, as those pins are intended for the debugging cable. What the kilobot is made of As you can see in the pictures above, one kilobot mainly has : 3 legs 2 rumble motors 1 LED a group of 2 power pins a group of 2 debug pins an IR transmitter an IR sensor a battery and a charging hook What the kilobot is up to Kilobots were designed to be very cheap, but are therefore very limited. They can perform simple task involving small movements, basic communication and distance sensing. However, as they move using vibrations, they can't have a reliable feedback of the movement executed. This makes it impossible to know neither their position nor their orientation. The lack of a second IR sensor also makes it impossible to know the position or orientation of the nearby kilobots. Using KiloGUI The kilobots come with a utility app to do various tasks with them, such as calibration, program transfer, debugging or execution control. You can download KiloGUI at the download section of the kilobotics website . To use KiloGUI, you will have to place the head controller of the kilobots on top of or beside the concerned kilobots and connect it to your PC. Connection with the kilobot should be instantaneous. Checking the battery of a kilobot You can check the battery power of the kilobot by using the KiloGUI interface. Simply press the \"Voltage\" button and the kilobot LED should light up. The color of the LED indicates the battery power : green means \"fully charged\" and red means \"barely charged\". Charging the kilobots The kilobots come with a charging bar where you can hang up to ten kilobots. Connect the charger to a power supply, then turn the kilobots on and hang them to the charger. The hook of the kilobot should be hung to the upper bar and the two rear legs of the kilobot should touch the lower bar. Calibrating a kilobot After pressing the \"calibrate\" button of KiloGUI, the following window should appear : With this window, you can give each kilobot a unique ID and specific calibration values . The \"test\" buttons allows to see the change in the kilobot's motion. From there you can adjust the values so that the kilobot is able to go straight and turn right and left reliably. When you're done, don't forget to save the parameters before you close the window.","title":"Getting started"},{"location":"guides/getting-started.html#getting-started-with-kilobots","text":"Here is a simple guide to get started with kilobots.","title":"Getting started with kilobots"},{"location":"guides/getting-started.html#turning-the-kilobot-on-and-off","text":"On the right side of the front leg are two pins. You probably also have a small red connector for those two pins. By placing the connector on the two pins, you turn the kilobot on and it should blink green. To turn the kilobot off , simply remove the connector. Note As not to lose the connector, you can simply place it on one pin. Warning Be sure not to place the connectors on the two pins that are on the left side of the front leg, as those pins are intended for the debugging cable.","title":"Turning the kilobot on and off"},{"location":"guides/getting-started.html#what-the-kilobot-is-made-of","text":"As you can see in the pictures above, one kilobot mainly has : 3 legs 2 rumble motors 1 LED a group of 2 power pins a group of 2 debug pins an IR transmitter an IR sensor a battery and a charging hook","title":"What the kilobot is made of"},{"location":"guides/getting-started.html#what-the-kilobot-is-up-to","text":"Kilobots were designed to be very cheap, but are therefore very limited. They can perform simple task involving small movements, basic communication and distance sensing. However, as they move using vibrations, they can't have a reliable feedback of the movement executed. This makes it impossible to know neither their position nor their orientation. The lack of a second IR sensor also makes it impossible to know the position or orientation of the nearby kilobots.","title":"What the kilobot is up to"},{"location":"guides/getting-started.html#using-kilogui","text":"The kilobots come with a utility app to do various tasks with them, such as calibration, program transfer, debugging or execution control. You can download KiloGUI at the download section of the kilobotics website . To use KiloGUI, you will have to place the head controller of the kilobots on top of or beside the concerned kilobots and connect it to your PC. Connection with the kilobot should be instantaneous.","title":"Using KiloGUI"},{"location":"guides/getting-started.html#checking-the-battery-of-a-kilobot","text":"You can check the battery power of the kilobot by using the KiloGUI interface. Simply press the \"Voltage\" button and the kilobot LED should light up. The color of the LED indicates the battery power : green means \"fully charged\" and red means \"barely charged\".","title":"Checking the battery of a kilobot"},{"location":"guides/getting-started.html#charging-the-kilobots","text":"The kilobots come with a charging bar where you can hang up to ten kilobots. Connect the charger to a power supply, then turn the kilobots on and hang them to the charger. The hook of the kilobot should be hung to the upper bar and the two rear legs of the kilobot should touch the lower bar.","title":"Charging the kilobots"},{"location":"guides/getting-started.html#calibrating-a-kilobot","text":"After pressing the \"calibrate\" button of KiloGUI, the following window should appear : With this window, you can give each kilobot a unique ID and specific calibration values . The \"test\" buttons allows to see the change in the kilobot's motion. From there you can adjust the values so that the kilobot is able to go straight and turn right and left reliably. When you're done, don't forget to save the parameters before you close the window.","title":"Calibrating a kilobot"},{"location":"guides/guide-index.html","text":"Guides The KiloGuide currently presents 5 guides. Getting started with kilobots Learn how to turn your kilobots on and off. Discover the components of a kilobot, what it can do with them. Calibrate your kilobots. Coding for kilobots Learn the basics of robot programming, which langage and which code templates are used to write programs for kilobots. Compile your code Learn how to convert your code into an executable file, that will be read by your kilobots. Transfer and run your program Learn how to transfer the executable file into your kilobots, start, pause and stop the program. Use the debug feature Learn how to use the simple debug feature with kilobots, to know what is not working in your programs.","title":"Guides summary"},{"location":"guides/guide-index.html#guides","text":"The KiloGuide currently presents 5 guides.","title":"Guides"},{"location":"guides/guide-index.html#getting-started-with-kilobots","text":"Learn how to turn your kilobots on and off. Discover the components of a kilobot, what it can do with them. Calibrate your kilobots.","title":"Getting started with kilobots"},{"location":"guides/guide-index.html#coding-for-kilobots","text":"Learn the basics of robot programming, which langage and which code templates are used to write programs for kilobots.","title":"Coding for kilobots"},{"location":"guides/guide-index.html#compile-your-code","text":"Learn how to convert your code into an executable file, that will be read by your kilobots.","title":"Compile your code"},{"location":"guides/guide-index.html#transfer-and-run-your-program","text":"Learn how to transfer the executable file into your kilobots, start, pause and stop the program.","title":"Transfer and run your program"},{"location":"guides/guide-index.html#use-the-debug-feature","text":"Learn how to use the simple debug feature with kilobots, to know what is not working in your programs.","title":"Use the debug feature"},{"location":"guides/transfer-and-run-your-program.html","text":"Transfer and run your programs Transfer a program to your kilobots Once you have successfully compiled your program, it's time to transfer it! To do so, we are going to use this part of the KiloGUI interface : Use the [select file] button to select the .hex file you will transfer into the kilobots. Here, we selected the body-1-OL.hex file. Be sure that KiloGUI is connected to the kilobots by hitting the Bootload button. The kilobots' LEDs should now be blue. You can then click the Upload button to start the transfer. The kilobots will blink green and blue alternatively during this process. Wait a few seconds. When the program has been transferred, the kilobots will get back to blink green slowly, indicating that they are ready to start the execution ! Warning If a kilobot only blinks blue and green for a short amount of time before turning off during transfer, a problem has occurred. Ensure your code does not contain syntaxical errors (if so, they should be displayed during compilation). Be sure the voltage of the kilobot is not too low (aka not red). Check that the ground on which the kilobot is placed is reflecting enough for IR communication. If none of these solutions work, try updating the kilobot firmware. Note If you experience trouble as above, consider trying different programs, kilobots and reflecting surfaces to identify the root of the problem. Run the program If the program transfer was successful, it's now time to start the execution! For this section, we are going to focus on this part of the KiloGUI interface : To start the execution, just press the Run button. The Pause button will stop the execution until the Run button is hit again. To make the kilobots go back to the starting point of the program, use the Reset button. The other buttons are not really linked to the program execution. Sleep will put the kilobots to sleep, Voltage will display the battery level using the kilobots' LEDs and LedToggle can be used to ensure that the connection between the kilobots and the head controller has been well established.","title":"Transfer and run your program"},{"location":"guides/transfer-and-run-your-program.html#transfer-and-run-your-programs","text":"","title":"Transfer and run your programs"},{"location":"guides/transfer-and-run-your-program.html#transfer-a-program-to-your-kilobots","text":"Once you have successfully compiled your program, it's time to transfer it! To do so, we are going to use this part of the KiloGUI interface : Use the [select file] button to select the .hex file you will transfer into the kilobots. Here, we selected the body-1-OL.hex file. Be sure that KiloGUI is connected to the kilobots by hitting the Bootload button. The kilobots' LEDs should now be blue. You can then click the Upload button to start the transfer. The kilobots will blink green and blue alternatively during this process. Wait a few seconds. When the program has been transferred, the kilobots will get back to blink green slowly, indicating that they are ready to start the execution ! Warning If a kilobot only blinks blue and green for a short amount of time before turning off during transfer, a problem has occurred. Ensure your code does not contain syntaxical errors (if so, they should be displayed during compilation). Be sure the voltage of the kilobot is not too low (aka not red). Check that the ground on which the kilobot is placed is reflecting enough for IR communication. If none of these solutions work, try updating the kilobot firmware. Note If you experience trouble as above, consider trying different programs, kilobots and reflecting surfaces to identify the root of the problem.","title":"Transfer a program to your kilobots"},{"location":"guides/transfer-and-run-your-program.html#run-the-program","text":"If the program transfer was successful, it's now time to start the execution! For this section, we are going to focus on this part of the KiloGUI interface : To start the execution, just press the Run button. The Pause button will stop the execution until the Run button is hit again. To make the kilobots go back to the starting point of the program, use the Reset button. The other buttons are not really linked to the program execution. Sleep will put the kilobots to sleep, Voltage will display the battery level using the kilobots' LEDs and LedToggle can be used to ensure that the connection between the kilobots and the head controller has been well established.","title":"Run the program"},{"location":"guides/use-the-debug-feature.html","text":"Use the debug features Sometimes the code can produce some unexpected behaviors. To help to find out the causes, kilobots are equipped with a very basic debugging feature. How to set up the debug feature Step 1 : Include debug.h In the first lines of your program, add the following lines : #define DEBUG #include <debug.h> Step 2 : Initialize the debugger In the main function of your program, add the following line between kilo_init() and kilo_start() : kilo_init(); debug_init(); // This line is new kilo_start(setup, loop); Step 3 : Add printf() s Debugging code on kilobots is actually just using the common C function printf() to send a string to the head controller and therefore the computer. You can use it to trace the execution of your program or to check the value of a variable. printf(\"%d\", kilo_ticks); // Example printing the value of kilo_ticks Step 4 : Connect the kilobot to the head controller That's where the two pins located on the left side of the kilobot's front leg come in to play. Connect those pins to the pins of the head controller like presented in these images : Note On some head controller, the 2 debug pins are located under the board. The white end of the connector cable needs to connect to the head, and the black end will connect to the kilobot. Step 5 : Open the Serial Input window After you transfer your compiled program to the kilobot, open the serial input window by clicking the Serial Input button. There you will see every message sent by the kilobot via the printf() function. We are done ! A complete example Here is a basic \"Hello world!\" program to test the debugging feature. You can download the source file here . #include <kilolib.h> #define DEBUG #include <debug.h> void setup() { printf(\"Hello world!\"); } void loop() { return; } int main() { kilo_init(); debug_init(); kilo_start(setup, loop); return 0; }","title":"Use the debug feature"},{"location":"guides/use-the-debug-feature.html#use-the-debug-features","text":"Sometimes the code can produce some unexpected behaviors. To help to find out the causes, kilobots are equipped with a very basic debugging feature.","title":"Use the debug features"},{"location":"guides/use-the-debug-feature.html#how-to-set-up-the-debug-feature","text":"","title":"How to set up the debug feature"},{"location":"guides/use-the-debug-feature.html#step-1-include-debugh","text":"In the first lines of your program, add the following lines : #define DEBUG #include <debug.h>","title":"Step 1 : Include debug.h"},{"location":"guides/use-the-debug-feature.html#step-2-initialize-the-debugger","text":"In the main function of your program, add the following line between kilo_init() and kilo_start() : kilo_init(); debug_init(); // This line is new kilo_start(setup, loop);","title":"Step 2 : Initialize the debugger"},{"location":"guides/use-the-debug-feature.html#step-3-add-printfs","text":"Debugging code on kilobots is actually just using the common C function printf() to send a string to the head controller and therefore the computer. You can use it to trace the execution of your program or to check the value of a variable. printf(\"%d\", kilo_ticks); // Example printing the value of kilo_ticks","title":"Step 3 : Add printf()s"},{"location":"guides/use-the-debug-feature.html#step-4-connect-the-kilobot-to-the-head-controller","text":"That's where the two pins located on the left side of the kilobot's front leg come in to play. Connect those pins to the pins of the head controller like presented in these images : Note On some head controller, the 2 debug pins are located under the board. The white end of the connector cable needs to connect to the head, and the black end will connect to the kilobot.","title":"Step 4 : Connect the kilobot to the head controller"},{"location":"guides/use-the-debug-feature.html#step-5-open-the-serial-input-window","text":"After you transfer your compiled program to the kilobot, open the serial input window by clicking the Serial Input button. There you will see every message sent by the kilobot via the printf() function. We are done !","title":"Step 5 : Open the Serial Input window"},{"location":"guides/use-the-debug-feature.html#a-complete-example","text":"Here is a basic \"Hello world!\" program to test the debugging feature. You can download the source file here . #include <kilolib.h> #define DEBUG #include <debug.h> void setup() { printf(\"Hello world!\"); } void loop() { return; } int main() { kilo_init(); debug_init(); kilo_start(setup, loop); return 0; }","title":"A complete example"},{"location":"tutorials/tuto-index.html","text":"Tutorials This guide currently presents 5 easy and diverse tutorials. Race Around the World Number of kilobots : 1 Topic : basic program and movement Learn the basics of robot programming with one single kilobot. Write a simple program to turn on its LED and make it move along a race track. Full Metal Kilobot Number of kilobots : 2 Topic : messages and communication Get into a more complex program, using communication between two kilobots in a creative way. One of the kilobots is the instructor, yelling orders to the rookie, which must then execute them more or less precisely. King-o-bot's Games Number of kilobots : 2 Topic : distance measuring In this tutorial inspired by the medieval knight's tournaments, the kilobots must fight in duel, going one toward the other at astounding speeds. The first to freak out loses and won't be King-o-bot's great champion! Morphogenetics Number of kilobots : arbitrary Topic : collective organization In living creatures' bodies, a cell can sometimes approximate its distance to another cell by analysing the neighbouring concentration of chemicals produced by that cell. Let's put this idea in practice with kilobots! Rush Hour Number of kilobots : arbitrary Topic : collective behavior In this tutorial, a lot of kilobots are placed in a limited space. As they move around randomly, they must display different colors depending on the number of kilobots they detect around them. The goal is to obtain some heat-map of the kilobot concentrations at a high scale.","title":"Tutorials summary"},{"location":"tutorials/tuto-index.html#tutorials","text":"This guide currently presents 5 easy and diverse tutorials.","title":"Tutorials"},{"location":"tutorials/tuto-index.html#race-around-the-world","text":"Number of kilobots : 1 Topic : basic program and movement Learn the basics of robot programming with one single kilobot. Write a simple program to turn on its LED and make it move along a race track.","title":"Race Around the World"},{"location":"tutorials/tuto-index.html#full-metal-kilobot","text":"Number of kilobots : 2 Topic : messages and communication Get into a more complex program, using communication between two kilobots in a creative way. One of the kilobots is the instructor, yelling orders to the rookie, which must then execute them more or less precisely.","title":"Full Metal Kilobot"},{"location":"tutorials/tuto-index.html#king-o-bots-games","text":"Number of kilobots : 2 Topic : distance measuring In this tutorial inspired by the medieval knight's tournaments, the kilobots must fight in duel, going one toward the other at astounding speeds. The first to freak out loses and won't be King-o-bot's great champion!","title":"King-o-bot's Games"},{"location":"tutorials/tuto-index.html#morphogenetics","text":"Number of kilobots : arbitrary Topic : collective organization In living creatures' bodies, a cell can sometimes approximate its distance to another cell by analysing the neighbouring concentration of chemicals produced by that cell. Let's put this idea in practice with kilobots!","title":"Morphogenetics"},{"location":"tutorials/tuto-index.html#rush-hour","text":"Number of kilobots : arbitrary Topic : collective behavior In this tutorial, a lot of kilobots are placed in a limited space. As they move around randomly, they must display different colors depending on the number of kilobots they detect around them. The goal is to obtain some heat-map of the kilobot concentrations at a high scale.","title":"Rush Hour"},{"location":"tutorials/tuto1.html","text":"Race around the world source code of this tutorial Summary In this tutorial, we are going to discover the basics of kilobot programming. This simple bunch of code will make a single kilobot race along a track in loop. The code in this tutorial is written for this racetrack . The kilobot starts the race with its front leg on the red point. Note that you can adapt it to any race track you want. Note We suggest you draw the racetrack onto the kilobot table using a whiteboard marker, so as to not make the robot run on a harsh surface. What you will learn Basic template for a kilobot program How to make the kilobot flash color with set_color() How to make the kilobot move with set_motors() Basics If you have already read the coding for kilobots guide, you already know that a kilobot program is divided in two main parts : the setup() function and the loop() function. The setup() function is only executed once, at the very start of the execution, and the loop() function is executed again and again until the kilobot is told to stop. The following sections will illustrate how these two components work to build a simple behavior for the kilobot. The setup() function Before the kilobot starts racing along the track, we are going to make it flash like the flashlight at the beginning of a real race. As this code is only ran once at the start, we are going to place it in the setup() function : void setup() { // Blinks red, yellow and green before startup set_color(RGB(1,0,0)); // red delay(1000); set_color(RGB(1,1,0)); // yellow delay(1000); set_color(RGB(0,1,0)); // green } Note The delay() function stops the execution of the program, but it doesn't stop the LED from shining. It is useful to turn the LED on for a certain amount of time. The loop() function The sequence of actions that a kilobot must do to race a single loop around the track will be placed here. void loop() { // Goes straight spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(2000); // Turns left spinup_motors(); set_motors(kilo_turn_left, kilo_straight_right/2); delay(5000); // Goes straight again spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(4000); // Turns right spinup_motors(); set_motors(kilo_straight_left/2, kilo_turn_right); delay(5000); // Goes straight to get back to the race starting point spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(2000); } To make the kilobot move, we use the set_motors() function. Before calling it, we must call the spinup_motors() function to avoid static friction effects. The two arguments of the set_motors() function indicate the power of each motor of the kilobot. Those values can go from 0 (off) to 255 (full speed). To take calibration into account, it is recommended to use the predefined values kilo_straight_left , kilo_straight_right , kilo_turn_left and kilo_turn_right rather than some raw numbers. Note Just as it did for the LED, the delay() function makes it possible to define the amount of time during which the motors must work. It doesn't stop the movement of the kilobot Note See how we used kilo_straight_left/2 and kilo_straight_right/2 when turning. This enables us to manage the angle of turn. The more we divide the value, the tighter the turn becomes. Replacing those expressions by 0 would give the tightest turns. Warning Kilobots movement depends on a lot of factors and is impredictable by nature. The values used in the delay() or set_motors() functions might be changed for them to work in your particular environment. The main() function We are almost done ! At this point, we only have to define the entry-point of our program : the main() function. int main() { // Initializes hardware kilo_init(); // Starts program kilo_start(setup, loop); return 0; } The main() function must always call kilo_init() , then kilo_start() in order to start the program. We are done ! You can now admire your kilobot burn the tarmac ! Well, it might not be that impressive. The kilobots were probably not designed as racing machines. But fair enough, it at least made you learn the basics of programming for kilobots !","title":"Race Around the World"},{"location":"tutorials/tuto1.html#race-around-the-world","text":"source code of this tutorial","title":"Race around the world"},{"location":"tutorials/tuto1.html#summary","text":"In this tutorial, we are going to discover the basics of kilobot programming. This simple bunch of code will make a single kilobot race along a track in loop. The code in this tutorial is written for this racetrack . The kilobot starts the race with its front leg on the red point. Note that you can adapt it to any race track you want. Note We suggest you draw the racetrack onto the kilobot table using a whiteboard marker, so as to not make the robot run on a harsh surface.","title":"Summary"},{"location":"tutorials/tuto1.html#what-you-will-learn","text":"Basic template for a kilobot program How to make the kilobot flash color with set_color() How to make the kilobot move with set_motors()","title":"What you will learn"},{"location":"tutorials/tuto1.html#basics","text":"If you have already read the coding for kilobots guide, you already know that a kilobot program is divided in two main parts : the setup() function and the loop() function. The setup() function is only executed once, at the very start of the execution, and the loop() function is executed again and again until the kilobot is told to stop. The following sections will illustrate how these two components work to build a simple behavior for the kilobot.","title":"Basics"},{"location":"tutorials/tuto1.html#the-setup-function","text":"Before the kilobot starts racing along the track, we are going to make it flash like the flashlight at the beginning of a real race. As this code is only ran once at the start, we are going to place it in the setup() function : void setup() { // Blinks red, yellow and green before startup set_color(RGB(1,0,0)); // red delay(1000); set_color(RGB(1,1,0)); // yellow delay(1000); set_color(RGB(0,1,0)); // green } Note The delay() function stops the execution of the program, but it doesn't stop the LED from shining. It is useful to turn the LED on for a certain amount of time.","title":"The setup() function"},{"location":"tutorials/tuto1.html#the-loop-function","text":"The sequence of actions that a kilobot must do to race a single loop around the track will be placed here. void loop() { // Goes straight spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(2000); // Turns left spinup_motors(); set_motors(kilo_turn_left, kilo_straight_right/2); delay(5000); // Goes straight again spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(4000); // Turns right spinup_motors(); set_motors(kilo_straight_left/2, kilo_turn_right); delay(5000); // Goes straight to get back to the race starting point spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(2000); } To make the kilobot move, we use the set_motors() function. Before calling it, we must call the spinup_motors() function to avoid static friction effects. The two arguments of the set_motors() function indicate the power of each motor of the kilobot. Those values can go from 0 (off) to 255 (full speed). To take calibration into account, it is recommended to use the predefined values kilo_straight_left , kilo_straight_right , kilo_turn_left and kilo_turn_right rather than some raw numbers. Note Just as it did for the LED, the delay() function makes it possible to define the amount of time during which the motors must work. It doesn't stop the movement of the kilobot Note See how we used kilo_straight_left/2 and kilo_straight_right/2 when turning. This enables us to manage the angle of turn. The more we divide the value, the tighter the turn becomes. Replacing those expressions by 0 would give the tightest turns. Warning Kilobots movement depends on a lot of factors and is impredictable by nature. The values used in the delay() or set_motors() functions might be changed for them to work in your particular environment.","title":"The loop() function"},{"location":"tutorials/tuto1.html#the-main-function","text":"We are almost done ! At this point, we only have to define the entry-point of our program : the main() function. int main() { // Initializes hardware kilo_init(); // Starts program kilo_start(setup, loop); return 0; } The main() function must always call kilo_init() , then kilo_start() in order to start the program.","title":"The main() function"},{"location":"tutorials/tuto1.html#we-are-done","text":"You can now admire your kilobot burn the tarmac ! Well, it might not be that impressive. The kilobots were probably not designed as racing machines. But fair enough, it at least made you learn the basics of programming for kilobots !","title":"We are done !"},{"location":"tutorials/tuto2.html","text":"Full Metal Kilobot source code of this tutorial Summary Now that we know the basics, let's tackle the real interesting thing about kilobots : make them communicate. This tutorial is inspired by the military training scenes in Kubrick's \"Full Metal Jacket\" movie . We will use two kilobots : one will be the instructor, the other will be the rookie. Therefore, we are going to write two distinct programs : the instructor's program, generating and sending random training instructions the rookie's program, executing instructions as fast as possible What you will learn How to create a message with the message_t structure How to generate random numbers with the rand_hard() function How to send messages with kilo_message_tx How to receive and read messages with kilo_message_rx Create messages Messages for kilobots are contained in the message_t structure, which has 3 fields : type , from 0 to 127, describing the type of the message. For this tutorial, we will only use the macro NORMAL data , an array of length 9, storing the real content of the message crc , an hash code, computed with the message_crc() function, used to check that data was not corrupted during transmission. We can define a message like this : message_t message; // This message will contain the answer to the ultimate question of life, universe and everything. message.type = NORMAL; message.data[0] = 42; message.crc = message_crc(&message); Create random numbers Kilobots have two functions to generate random numbers : rand_soft() generates a random number from a seed. You can provide a specific seed using the rand_seed() function. rand_hard() generates a random number from the kilobot's hardware, namely its battery precise voltage. As rand_hard() is slower than rand_soft() , it is common to use rand_soft() when we need random numbers multiple times per second. In that situation, we can use rand_hard() inside rand_seed() to initialize the RNG. In this tutorial, we will only use the rand_hard() function as we do not need efficiency. Instructor's program Let's get into the real code ! Instructions The first step is to define a protocol used by the two kilobots to communicate. It seems difficult but it really is fairly simple. We have 3 different possible instructions : \" Show me your war face! \" \u27f6 Light the led \" Turn on yourself x times! \" \u27f6 Set motors to do x turns on itself \" Run x cm and come back! \" \u27f6 Set motors to run x cm, turn around and come back A simple protocol would be : \"Each instruction has an ID, from 1 to 3, stored in the first byte of data . Instructions 2 and 3 have a parameter, stored in the second byte of data .\" So for example, \"Turn on yourself 3 times!\" would translate to the following message : message_t message; message.type = NORMAL; message.data[0] = 2; // Turn on yourself... message.data[1] = 3; // ...3 times! message.crc = message_crc(&message); We can now write a simple program that will generate a random instruction : message_t instruction; int instructionID; int instructionParam; void makeInstruction() { // Creates an instruction to be given to the rookie instruction.type = NORMAL; instruction.data[0] = instructionID; instruction.data[1] = instructionParam; instruction.crc = message_crc(&instruction); } void generateInstruction() { // Gives an instruction to the rookie // Choses the instruction instructionID = (rand_hard() % 3) + 1; // Instructions have a specific number, from 1 to 3 // Depending on the instruction, generates a random parameter switch (instructionID) { case 1: // Rookie must show his war face ! (Turn on his led) instructionParam = 0; break; case 2: // Rookie must run x centimeters, then come back. instructionParam = 3 + (rand_hard() % 8); // Cm to be runned, from 3 to 10 break; case 3: // Rookie must turn around on himself x times. instructionParam = 1 + (rand_hard() % 3); // number of turns, from 1 to 3 break; } makeInstruction(); } Note Note how we put instruction , instructionID and instructionParam as global variables. It makes it possible to access them from anywhere in the code, though we must be careful with the way each part of the program manipulates them. Message handling To handle communication, we need to define two functions. One (commonly named message_tx() ) will be called when sending a message, the other (commonly named message_rx() ) will be called when receiving a message. We also have to define a flag, which is a variable with value 0 or 1 describing the \"state\" of the robot. In our case, the instructionGiven flag tells wether or not an instruction has been given to the rookie. If its value is 0, the instructor should generate and send a new instruction. If it's 1, the instructor waits for the rookie to finish. int instructionGiven = 0; message_t* message_tx() { // This function returns the instruction to send to the rookie return &instruction; } void message_rx(message_t *msg, distance_measurement_t *dist) { // This function is called when the rookie has finished executing his order and is ready for a new one. instructionGiven = 0; } Note Notice the two parameters of the message_rx function. They are mandatory to define the function, but of no use for the instructor. Setup and loop The setup function for the instructor is rather minimalistic, it's even empty in fact. The instructor does not care about anything except yelling orders repeatedly. In the loop function, we will either generate a new instruction or wait for the rookie. When generating a new instruction, the instructor will indicate the instruction chosen by turning on its LED with a specific color. When waiting, the instructor blinks yellow. void setup() { } void loop() { if (!instructionGiven) { // Gives an order. Blinks a specific color depending on the given order generateInstruction(); switch (instructionID) { case 1: set_color(RGB(1,0, 0)); // Blinks red break; case 2: set_color(RGB(0, 1, 0)); // Blinks green break; case 3: set_color(RGB(0, 0, 1)); // Blinks green to break; } delay(500); set_color(RGB(0,0,0)); instructionGiven = 1; // Changes the flag } else { // Waits for the rookie. Blinks yellow delay(500); set_color(RGB(1,1,0)); delay(500); set_color(RGB(0,0,0)); } } Note Even if the setup() function is empty, we must define it, as it must be passed to the kilo_start() function. Put it together The only thing left to do is to define the main function. kilo_message_tx and kilo_message_rx are system variables used to specify which function to call when sending/receiving a message. int main() { // initialize hardware kilo_init(); // Registers the function to call when sending a instruction kilo_message_tx = message_tx; // Registers the function to call when rookie says he is ready kilo_message_rx = message_rx; // start program kilo_start(setup, loop); return 0; } Rookie's program Most of the aspects of the rookie's program have already been seen in the instructor's program. In this section, we will only focus on the new things. Message handling Sending messages The rookie must only send a message to say that he is ready, so the message doesn't need to contain any data : the mere fact that he is sending a message already tells the purpose of the message. And as you can see above, the instructor never cares about the content of the message. The rookie will also use a flag to tell wether he is ready for an instruction or not. These facts give the following code : #include <stddef.h> // Defines 'NULL' macro message_t ready; int waitingForInstruction = 0; void setup() { // Waits to be called by the instructor waitingForInstruction = 1; // Initialize the message ready.type = NORMAL; ready.crc = message_crc(&ready); } message_t* message_tx() { // Sends a message if the rookie is ready. If not, sends nothing. if (waitingForInstruction) { return &ready; } return NULL; } Receiving messages As for the instructor's program, the rookie will receive message with the message_rx() function. Here, the msg parameter is useful to retrieve the content of the message : int instructionID = 0; int instructionParam = 0; void message_rx(message_t *msg, distance_measurement_t *dist) { // This function is called when the rookie receives an instruction instructionID = msg->data[0]; instructionParam = msg->data[1]; waitingForInstruction = 0; } The loop In the loop function, the rookie will either execute an instruction, or wait to receive one. When waiting, it blinks yellow. int straightSpeedCalibrator = 1000; // Delay in milliseconds to go straight on 1cm int turningSpeedCalibrator = 5000; // Delay in milliseconds to make 1 turn around void loop() { if (waitingForInstruction) { // Waits for orders. Blinks yellow delay(500); set_color(RGB(1,1,0)); delay(500); set_color(RGB(0,0,0)); } else { switch(instructionID) { case 1: // Rookie shows his war face set_color(RGB(0, 1, 1)); delay(500); set_color(RGB(0,0,0)); break; case 2: // Rookie runs x centimeters, then comes back for (int i = 0 ; i < 2 ; i++) { spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(instructionParam * straightSpeedCalibrator); set_motors(kilo_turn_left, 0); delay(turningSpeedCalibrator); set_motors(0, 0); } break; case 3: // Rookie turns around on himself x times for (int i = 0 ; i < instructionParam ; i++) { spinup_motors(); set_motors(kilo_turn_left, 0); delay(turningSpeedCalibrator); set_motors(0, 0); } break; } waitingForInstruction = 1; delay(2000); // Waits two seconds before executing the next instruction } } Note Notice the use of straightSpeedCalibrator and turningSpeedCalibrator . These variables are used to indicate the time the kilobot takes to do a specific movement. Set them to the most fitting values depending on your kilobot specificities. Put it together The main() function is nothing new at this point: int main() { // Initializes hardware kilo_init(); // Registers the function to call when receiving a instruction kilo_message_rx = message_rx; // Registers the function to call when sending a message kilo_message_tx = message_tx; // Starts program kilo_start(setup, loop); return 0; } We are done ! You can now admire two kilobots in a tough military training. You've mastered the art of communication and are ready to get into the next tutorial !","title":"Full Metal Kilobot"},{"location":"tutorials/tuto2.html#full-metal-kilobot","text":"source code of this tutorial","title":"Full Metal Kilobot"},{"location":"tutorials/tuto2.html#summary","text":"Now that we know the basics, let's tackle the real interesting thing about kilobots : make them communicate. This tutorial is inspired by the military training scenes in Kubrick's \"Full Metal Jacket\" movie . We will use two kilobots : one will be the instructor, the other will be the rookie. Therefore, we are going to write two distinct programs : the instructor's program, generating and sending random training instructions the rookie's program, executing instructions as fast as possible","title":"Summary"},{"location":"tutorials/tuto2.html#what-you-will-learn","text":"How to create a message with the message_t structure How to generate random numbers with the rand_hard() function How to send messages with kilo_message_tx How to receive and read messages with kilo_message_rx","title":"What you will learn"},{"location":"tutorials/tuto2.html#create-messages","text":"Messages for kilobots are contained in the message_t structure, which has 3 fields : type , from 0 to 127, describing the type of the message. For this tutorial, we will only use the macro NORMAL data , an array of length 9, storing the real content of the message crc , an hash code, computed with the message_crc() function, used to check that data was not corrupted during transmission. We can define a message like this : message_t message; // This message will contain the answer to the ultimate question of life, universe and everything. message.type = NORMAL; message.data[0] = 42; message.crc = message_crc(&message);","title":"Create messages"},{"location":"tutorials/tuto2.html#create-random-numbers","text":"Kilobots have two functions to generate random numbers : rand_soft() generates a random number from a seed. You can provide a specific seed using the rand_seed() function. rand_hard() generates a random number from the kilobot's hardware, namely its battery precise voltage. As rand_hard() is slower than rand_soft() , it is common to use rand_soft() when we need random numbers multiple times per second. In that situation, we can use rand_hard() inside rand_seed() to initialize the RNG. In this tutorial, we will only use the rand_hard() function as we do not need efficiency.","title":"Create random numbers"},{"location":"tutorials/tuto2.html#instructors-program","text":"Let's get into the real code !","title":"Instructor's program"},{"location":"tutorials/tuto2.html#instructions","text":"The first step is to define a protocol used by the two kilobots to communicate. It seems difficult but it really is fairly simple. We have 3 different possible instructions : \" Show me your war face! \" \u27f6 Light the led \" Turn on yourself x times! \" \u27f6 Set motors to do x turns on itself \" Run x cm and come back! \" \u27f6 Set motors to run x cm, turn around and come back A simple protocol would be : \"Each instruction has an ID, from 1 to 3, stored in the first byte of data . Instructions 2 and 3 have a parameter, stored in the second byte of data .\" So for example, \"Turn on yourself 3 times!\" would translate to the following message : message_t message; message.type = NORMAL; message.data[0] = 2; // Turn on yourself... message.data[1] = 3; // ...3 times! message.crc = message_crc(&message); We can now write a simple program that will generate a random instruction : message_t instruction; int instructionID; int instructionParam; void makeInstruction() { // Creates an instruction to be given to the rookie instruction.type = NORMAL; instruction.data[0] = instructionID; instruction.data[1] = instructionParam; instruction.crc = message_crc(&instruction); } void generateInstruction() { // Gives an instruction to the rookie // Choses the instruction instructionID = (rand_hard() % 3) + 1; // Instructions have a specific number, from 1 to 3 // Depending on the instruction, generates a random parameter switch (instructionID) { case 1: // Rookie must show his war face ! (Turn on his led) instructionParam = 0; break; case 2: // Rookie must run x centimeters, then come back. instructionParam = 3 + (rand_hard() % 8); // Cm to be runned, from 3 to 10 break; case 3: // Rookie must turn around on himself x times. instructionParam = 1 + (rand_hard() % 3); // number of turns, from 1 to 3 break; } makeInstruction(); } Note Note how we put instruction , instructionID and instructionParam as global variables. It makes it possible to access them from anywhere in the code, though we must be careful with the way each part of the program manipulates them.","title":"Instructions"},{"location":"tutorials/tuto2.html#message-handling","text":"To handle communication, we need to define two functions. One (commonly named message_tx() ) will be called when sending a message, the other (commonly named message_rx() ) will be called when receiving a message. We also have to define a flag, which is a variable with value 0 or 1 describing the \"state\" of the robot. In our case, the instructionGiven flag tells wether or not an instruction has been given to the rookie. If its value is 0, the instructor should generate and send a new instruction. If it's 1, the instructor waits for the rookie to finish. int instructionGiven = 0; message_t* message_tx() { // This function returns the instruction to send to the rookie return &instruction; } void message_rx(message_t *msg, distance_measurement_t *dist) { // This function is called when the rookie has finished executing his order and is ready for a new one. instructionGiven = 0; } Note Notice the two parameters of the message_rx function. They are mandatory to define the function, but of no use for the instructor.","title":"Message handling"},{"location":"tutorials/tuto2.html#setup-and-loop","text":"The setup function for the instructor is rather minimalistic, it's even empty in fact. The instructor does not care about anything except yelling orders repeatedly. In the loop function, we will either generate a new instruction or wait for the rookie. When generating a new instruction, the instructor will indicate the instruction chosen by turning on its LED with a specific color. When waiting, the instructor blinks yellow. void setup() { } void loop() { if (!instructionGiven) { // Gives an order. Blinks a specific color depending on the given order generateInstruction(); switch (instructionID) { case 1: set_color(RGB(1,0, 0)); // Blinks red break; case 2: set_color(RGB(0, 1, 0)); // Blinks green break; case 3: set_color(RGB(0, 0, 1)); // Blinks green to break; } delay(500); set_color(RGB(0,0,0)); instructionGiven = 1; // Changes the flag } else { // Waits for the rookie. Blinks yellow delay(500); set_color(RGB(1,1,0)); delay(500); set_color(RGB(0,0,0)); } } Note Even if the setup() function is empty, we must define it, as it must be passed to the kilo_start() function.","title":"Setup and loop"},{"location":"tutorials/tuto2.html#put-it-together","text":"The only thing left to do is to define the main function. kilo_message_tx and kilo_message_rx are system variables used to specify which function to call when sending/receiving a message. int main() { // initialize hardware kilo_init(); // Registers the function to call when sending a instruction kilo_message_tx = message_tx; // Registers the function to call when rookie says he is ready kilo_message_rx = message_rx; // start program kilo_start(setup, loop); return 0; }","title":"Put it together"},{"location":"tutorials/tuto2.html#rookies-program","text":"Most of the aspects of the rookie's program have already been seen in the instructor's program. In this section, we will only focus on the new things.","title":"Rookie's program"},{"location":"tutorials/tuto2.html#message-handling_1","text":"","title":"Message handling"},{"location":"tutorials/tuto2.html#sending-messages","text":"The rookie must only send a message to say that he is ready, so the message doesn't need to contain any data : the mere fact that he is sending a message already tells the purpose of the message. And as you can see above, the instructor never cares about the content of the message. The rookie will also use a flag to tell wether he is ready for an instruction or not. These facts give the following code : #include <stddef.h> // Defines 'NULL' macro message_t ready; int waitingForInstruction = 0; void setup() { // Waits to be called by the instructor waitingForInstruction = 1; // Initialize the message ready.type = NORMAL; ready.crc = message_crc(&ready); } message_t* message_tx() { // Sends a message if the rookie is ready. If not, sends nothing. if (waitingForInstruction) { return &ready; } return NULL; }","title":"Sending messages"},{"location":"tutorials/tuto2.html#receiving-messages","text":"As for the instructor's program, the rookie will receive message with the message_rx() function. Here, the msg parameter is useful to retrieve the content of the message : int instructionID = 0; int instructionParam = 0; void message_rx(message_t *msg, distance_measurement_t *dist) { // This function is called when the rookie receives an instruction instructionID = msg->data[0]; instructionParam = msg->data[1]; waitingForInstruction = 0; }","title":"Receiving messages"},{"location":"tutorials/tuto2.html#the-loop","text":"In the loop function, the rookie will either execute an instruction, or wait to receive one. When waiting, it blinks yellow. int straightSpeedCalibrator = 1000; // Delay in milliseconds to go straight on 1cm int turningSpeedCalibrator = 5000; // Delay in milliseconds to make 1 turn around void loop() { if (waitingForInstruction) { // Waits for orders. Blinks yellow delay(500); set_color(RGB(1,1,0)); delay(500); set_color(RGB(0,0,0)); } else { switch(instructionID) { case 1: // Rookie shows his war face set_color(RGB(0, 1, 1)); delay(500); set_color(RGB(0,0,0)); break; case 2: // Rookie runs x centimeters, then comes back for (int i = 0 ; i < 2 ; i++) { spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(instructionParam * straightSpeedCalibrator); set_motors(kilo_turn_left, 0); delay(turningSpeedCalibrator); set_motors(0, 0); } break; case 3: // Rookie turns around on himself x times for (int i = 0 ; i < instructionParam ; i++) { spinup_motors(); set_motors(kilo_turn_left, 0); delay(turningSpeedCalibrator); set_motors(0, 0); } break; } waitingForInstruction = 1; delay(2000); // Waits two seconds before executing the next instruction } } Note Notice the use of straightSpeedCalibrator and turningSpeedCalibrator . These variables are used to indicate the time the kilobot takes to do a specific movement. Set them to the most fitting values depending on your kilobot specificities.","title":"The loop"},{"location":"tutorials/tuto2.html#put-it-together_1","text":"The main() function is nothing new at this point: int main() { // Initializes hardware kilo_init(); // Registers the function to call when receiving a instruction kilo_message_rx = message_rx; // Registers the function to call when sending a message kilo_message_tx = message_tx; // Starts program kilo_start(setup, loop); return 0; }","title":"Put it together"},{"location":"tutorials/tuto2.html#we-are-done","text":"You can now admire two kilobots in a tough military training. You've mastered the art of communication and are ready to get into the next tutorial !","title":"We are done !"},{"location":"tutorials/tuto3.html","text":"King-o-bot's Games source code of this tutorial Summary By now you should have mastered the movement and communication abilities of kilobots. However, there is one last sensing ability you have yet to discover : distance sensing. Kilobots can evaluate their distance from another kilobot when they receive a message : that's the purpose of the message_rx() function's second argument. In this simple tutorial, we are going to put two kilobots one in front of the other. As medieval knights, they will charge the other. However, the kilobots are really fearful and, when they will reach their personal distance limit, they will freak out and give up. What you will learn How to evaluate distance with the distance_measurement_t argument and estimate_distance() More complex state management Knight's program Defining macros and global variables To make our program more configurable and readable, we are going to use C macros . The first two macros are used to define boundaries for the kilobot's distance limit. The four following macros define the kilobot's state. #define MIN_DISTANCE 35 #define MAX_DISTANCE 70 #define CHARGING 0 #define FREAKING_OUT 1 #define WON 2 #define LOST 3 Our program will also use 3 global variables. One will contain the kilobot's distance limit, the second contains its state and the last one is used for storing messages. int distanceLimit; int state; message_t message; The setup() function Here we define the kilobot's custom distance limit using rand_hard() . We set the initial state : at the beginning, the two kilobots are charging . When communicating, the kilobot will send its state in data , so that the other kilobot know when its opponent freaks out. Finally, we set the color to an aggressive red and make the kilobot run forward. void setup() { // Set the distance limit. distanceLimit = (rand_hard() % (MAX_DISTANCE - MIN_DISTANCE)) + MIN_DISTANCE; // Set the state state = CHARGING; // Set the message message.type = NORMAL; message.data[0] = state; message.crc = message_crc(&message); // Set light and movement set_color(RGB(3, 0, 0)); spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); } Note We defined MIN_DISTANCE and MAX_DISTANCE to be 35 and 70 millimeters respectively. This means that distanceLimit will always be between those two values. Communications Now this is the big part of this tutorial. The message_tx() function is quite classic know : message_t* message_tx() { return &message; } The message_rx() function however, is where the magic happens. Here, we analyse the state of the opponent and its distance from us. If the opponent is still charging and is closer than our distance limit, we start to freak out and surrender. If the opponent is freaking out on the other hand, we win and stop moving. void message_rx(message_t *m, distance_measurement_t *d) { if (state == CHARGING && m->data[0] == CHARGING) { // The kilobot and his opponent are still charging each other if (estimate_distance(d) < distanceLimit) { // The kilobot freaks out and surrender state = FREAKING_OUT; // Change message message.data[0] = state; message.crc = message_crc(&message); // Change movement spinup_motors(); set_motors(0, kilo_turn_right); } } else if (m->data[0]) { // The oponnent is freaking out state = WON; // Stop charging spinup_motors(); set_motors(0, 0); } } Here you can see how measuring distance is easy. We only need to pass the second argument of message_rx() to estimate_distance() . The result is an approximation of the distance between the two kilobots in millimeters. It can be stored as an int and compared with the distanceLimit we have defined earlier. The loop() function The loop() function will take care of the kilobot's shown behavior depending on its state. void loop() { if (state == CHARGING) { // The kilobot is charging : blink red set_color(RGB(3, 0, 0)); delay(100); set_color(RGB(0, 0, 0)); delay(100); } else if (state == FREAKING_OUT) { // The kilobot is freaking out : quickly blink white for 2 seconds for (int i = 0 ; i < 2000 ; i += 200) { set_color(RGB(3, 3, 3)); delay(100); set_color(RGB(0, 0, 0)); delay(100); } // The kilobot is calming down, he lost set_motors(0, 0); state = LOST; } else if (state == WON) { // The kilobot won the fight : blink blue, green and yellow set_color(RGB(0, 0, 3)); delay(100); set_color(RGB(0, 3, 0)); delay(100); set_color(RGB(3, 3, 0)); delay(100); } else { // The kilobot lost the fight : slowly, shamefully blinks white set_color(RGB(1, 1, 1)); delay(2000); set_color(RGB(0, 0, 0)); delay(2000); } } Put it all together Once again, nothing new in the main() function : int main() { kilo_init(); kilo_message_tx = message_tx; kilo_message_rx = message_rx; kilo_start(setup, loop); return 0; } We are done ! You can now make impressive and quite shocking kilobots duels ! Place them in front of each other, start and watch them charge... until one freaks out. You have mastered distance sensing and are now ready to code some complex programs for kilobots. It's now time to implement collective behaviors with a bigger number of kilobots.","title":"King-o-bot's Games"},{"location":"tutorials/tuto3.html#king-o-bots-games","text":"source code of this tutorial","title":"King-o-bot's Games"},{"location":"tutorials/tuto3.html#summary","text":"By now you should have mastered the movement and communication abilities of kilobots. However, there is one last sensing ability you have yet to discover : distance sensing. Kilobots can evaluate their distance from another kilobot when they receive a message : that's the purpose of the message_rx() function's second argument. In this simple tutorial, we are going to put two kilobots one in front of the other. As medieval knights, they will charge the other. However, the kilobots are really fearful and, when they will reach their personal distance limit, they will freak out and give up.","title":"Summary"},{"location":"tutorials/tuto3.html#what-you-will-learn","text":"How to evaluate distance with the distance_measurement_t argument and estimate_distance() More complex state management","title":"What you will learn"},{"location":"tutorials/tuto3.html#knights-program","text":"","title":"Knight's program"},{"location":"tutorials/tuto3.html#defining-macros-and-global-variables","text":"To make our program more configurable and readable, we are going to use C macros . The first two macros are used to define boundaries for the kilobot's distance limit. The four following macros define the kilobot's state. #define MIN_DISTANCE 35 #define MAX_DISTANCE 70 #define CHARGING 0 #define FREAKING_OUT 1 #define WON 2 #define LOST 3 Our program will also use 3 global variables. One will contain the kilobot's distance limit, the second contains its state and the last one is used for storing messages. int distanceLimit; int state; message_t message;","title":"Defining macros and global variables"},{"location":"tutorials/tuto3.html#the-setup-function","text":"Here we define the kilobot's custom distance limit using rand_hard() . We set the initial state : at the beginning, the two kilobots are charging . When communicating, the kilobot will send its state in data , so that the other kilobot know when its opponent freaks out. Finally, we set the color to an aggressive red and make the kilobot run forward. void setup() { // Set the distance limit. distanceLimit = (rand_hard() % (MAX_DISTANCE - MIN_DISTANCE)) + MIN_DISTANCE; // Set the state state = CHARGING; // Set the message message.type = NORMAL; message.data[0] = state; message.crc = message_crc(&message); // Set light and movement set_color(RGB(3, 0, 0)); spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); } Note We defined MIN_DISTANCE and MAX_DISTANCE to be 35 and 70 millimeters respectively. This means that distanceLimit will always be between those two values.","title":"The setup() function"},{"location":"tutorials/tuto3.html#communications","text":"Now this is the big part of this tutorial. The message_tx() function is quite classic know : message_t* message_tx() { return &message; } The message_rx() function however, is where the magic happens. Here, we analyse the state of the opponent and its distance from us. If the opponent is still charging and is closer than our distance limit, we start to freak out and surrender. If the opponent is freaking out on the other hand, we win and stop moving. void message_rx(message_t *m, distance_measurement_t *d) { if (state == CHARGING && m->data[0] == CHARGING) { // The kilobot and his opponent are still charging each other if (estimate_distance(d) < distanceLimit) { // The kilobot freaks out and surrender state = FREAKING_OUT; // Change message message.data[0] = state; message.crc = message_crc(&message); // Change movement spinup_motors(); set_motors(0, kilo_turn_right); } } else if (m->data[0]) { // The oponnent is freaking out state = WON; // Stop charging spinup_motors(); set_motors(0, 0); } } Here you can see how measuring distance is easy. We only need to pass the second argument of message_rx() to estimate_distance() . The result is an approximation of the distance between the two kilobots in millimeters. It can be stored as an int and compared with the distanceLimit we have defined earlier.","title":"Communications"},{"location":"tutorials/tuto3.html#the-loop-function","text":"The loop() function will take care of the kilobot's shown behavior depending on its state. void loop() { if (state == CHARGING) { // The kilobot is charging : blink red set_color(RGB(3, 0, 0)); delay(100); set_color(RGB(0, 0, 0)); delay(100); } else if (state == FREAKING_OUT) { // The kilobot is freaking out : quickly blink white for 2 seconds for (int i = 0 ; i < 2000 ; i += 200) { set_color(RGB(3, 3, 3)); delay(100); set_color(RGB(0, 0, 0)); delay(100); } // The kilobot is calming down, he lost set_motors(0, 0); state = LOST; } else if (state == WON) { // The kilobot won the fight : blink blue, green and yellow set_color(RGB(0, 0, 3)); delay(100); set_color(RGB(0, 3, 0)); delay(100); set_color(RGB(3, 3, 0)); delay(100); } else { // The kilobot lost the fight : slowly, shamefully blinks white set_color(RGB(1, 1, 1)); delay(2000); set_color(RGB(0, 0, 0)); delay(2000); } }","title":"The loop() function"},{"location":"tutorials/tuto3.html#put-it-all-together","text":"Once again, nothing new in the main() function : int main() { kilo_init(); kilo_message_tx = message_tx; kilo_message_rx = message_rx; kilo_start(setup, loop); return 0; }","title":"Put it all together"},{"location":"tutorials/tuto3.html#we-are-done","text":"You can now make impressive and quite shocking kilobots duels ! Place them in front of each other, start and watch them charge... until one freaks out. You have mastered distance sensing and are now ready to code some complex programs for kilobots. It's now time to implement collective behaviors with a bigger number of kilobots.","title":"We are done !"},{"location":"tutorials/tuto4.html","text":"Morphogenetics source code of this tutorial Summary In most animals' bodies, some cells are able to feel their distance from other cells using chemicals propagation. The main use of this ability is to form complex shapes and tissues. The field of morphogenetic robotics takes inspiration from this to develop self-organized communities of robots. In this tutorial, we are going to develop a very simplified morphogenesis algorithm. It works with one 'source' kilobot and multiple 'cell' kilobots. Each 'cell' kilobot will be able to deduct its distance from the 'source' kilobot by communicating with its neighbors. The kilobots won't move, but they will use their LED to indicate their distance level. What you will learn How to implement a basic collective behavior Source's program The source kilobot is fairly simple. He will only send a message telling its level : 0. To recognize it from the other kilobots, we will set its LED to white. The setup() function message_t message; int level = 0; // 0 as this cell is the source void setup() { // Set message content message.type = NORMAL; message.data[0] = level; message.crc = message_crc(&message); // Set light set_color(RGB(3, 3, 3)); } Other functions As said above, the source kilobot really has nothing to do, so the loop() is just empty : void loop() { // Nothing to do } The message_tx() function is also quite common : message_t* message_tx() { return &message; } And once again, the main() function is nothing new : int main() { // initialize hardware kilo_init(); kilo_message_tx = message_tx; // start program kilo_start(setup, loop); return 0; } Cell's program Here's the tough part of the tutorial. Just as the source, the cells will communicate their current level with their neighbors. However, if a cell receive a message from a cell with a level 2 or more times lower than its own, it must update its level. Macros, message and setup() For a better configurability, we will define the MAX_LEVEL and TIMEOUT macros. MAX_LEVEL is the maximum distance level of all cells. TIMEOUT is used to know when to increase the cell's level : if a cell has no news from another cell with a lower level for a long time, it must deduct that it is now further away from the source and update its level accordingly. The timer variable will measure the time since last contact with a lower-level cell. #define MAX_LEVEL 5 #define TIMEOUT 30 message_t message; int level = MAX_LEVEL; // The cell starts at MAX_LEVEL int timer = 0; void setup() { message.type = NORMAL; } Sending and receiving messages In message_rx() , the cell analyses messages from its neighbors. If one of its neighbors' level is 2 or more times lower than its own level, it updates. If the level is just under its own, it resets its timer. void message_rx(message_t *m, distance_measurement_t *d) { if (m->data[0] < level-1) { // Change level level = m->data[0] + 1; timer = 0; } if (m->data[0] == level-1) { // Reset timer timer = 0; } } In message_tx() , we update the message content with the current level just before sending the message : message_t* message_tx() { message.data[0] = level; message.crc = message_crc(&message); return &message; } The loop() function Every time we enter the loop() , we increase the timer. If it is above TIMEOUT , we decrement the cell's level. The cell will also display different shades from green to red depending on its level. void loop() { // Update timer timer++; if (timer >= TIMEOUT && level < MAX_LEVEL) { // Timeout level++; timer = 0; } // Set light switch (level) { case 1: set_color(RGB(0, 3, 0)); delay(50); break; case 2: set_color(RGB(1, 3, 0)); delay(50); break; case 3: set_color(RGB(3, 3, 0)); delay(50); break; case 4: set_color(RGB(3, 1, 0)); delay(50); break; case MAX_LEVEL: set_color(RGB(3, 0, 0)); delay(50); break; } } Note As the TIMEOUT is set to 30 and the loop() takes 50 milliseconds to execute, a timeout take roughly 1,5 seconds to occur. Put it all together Don't forget the main() function! int main() { // initialize hardware kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; // start program kilo_start(setup, loop); return 0; } We are done ! You can now play with the kilobots, moving them around. Try and see what happens when you change the location of the source kilobot. You can also play around with MAX_LEVEL and TIMEOUT , seeing the effects of each change. If you want to go further, why not make the source/cells move randomly? What happens when you have multiple 'source' kilobots? The possibilities are endless.","title":"Morphogenetics"},{"location":"tutorials/tuto4.html#morphogenetics","text":"source code of this tutorial","title":"Morphogenetics"},{"location":"tutorials/tuto4.html#summary","text":"In most animals' bodies, some cells are able to feel their distance from other cells using chemicals propagation. The main use of this ability is to form complex shapes and tissues. The field of morphogenetic robotics takes inspiration from this to develop self-organized communities of robots. In this tutorial, we are going to develop a very simplified morphogenesis algorithm. It works with one 'source' kilobot and multiple 'cell' kilobots. Each 'cell' kilobot will be able to deduct its distance from the 'source' kilobot by communicating with its neighbors. The kilobots won't move, but they will use their LED to indicate their distance level.","title":"Summary"},{"location":"tutorials/tuto4.html#what-you-will-learn","text":"How to implement a basic collective behavior","title":"What you will learn"},{"location":"tutorials/tuto4.html#sources-program","text":"The source kilobot is fairly simple. He will only send a message telling its level : 0. To recognize it from the other kilobots, we will set its LED to white.","title":"Source's program"},{"location":"tutorials/tuto4.html#the-setup-function","text":"message_t message; int level = 0; // 0 as this cell is the source void setup() { // Set message content message.type = NORMAL; message.data[0] = level; message.crc = message_crc(&message); // Set light set_color(RGB(3, 3, 3)); }","title":"The setup() function"},{"location":"tutorials/tuto4.html#other-functions","text":"As said above, the source kilobot really has nothing to do, so the loop() is just empty : void loop() { // Nothing to do } The message_tx() function is also quite common : message_t* message_tx() { return &message; } And once again, the main() function is nothing new : int main() { // initialize hardware kilo_init(); kilo_message_tx = message_tx; // start program kilo_start(setup, loop); return 0; }","title":"Other functions"},{"location":"tutorials/tuto4.html#cells-program","text":"Here's the tough part of the tutorial. Just as the source, the cells will communicate their current level with their neighbors. However, if a cell receive a message from a cell with a level 2 or more times lower than its own, it must update its level.","title":"Cell's program"},{"location":"tutorials/tuto4.html#macros-message-and-setup","text":"For a better configurability, we will define the MAX_LEVEL and TIMEOUT macros. MAX_LEVEL is the maximum distance level of all cells. TIMEOUT is used to know when to increase the cell's level : if a cell has no news from another cell with a lower level for a long time, it must deduct that it is now further away from the source and update its level accordingly. The timer variable will measure the time since last contact with a lower-level cell. #define MAX_LEVEL 5 #define TIMEOUT 30 message_t message; int level = MAX_LEVEL; // The cell starts at MAX_LEVEL int timer = 0; void setup() { message.type = NORMAL; }","title":"Macros, message and setup()"},{"location":"tutorials/tuto4.html#sending-and-receiving-messages","text":"In message_rx() , the cell analyses messages from its neighbors. If one of its neighbors' level is 2 or more times lower than its own level, it updates. If the level is just under its own, it resets its timer. void message_rx(message_t *m, distance_measurement_t *d) { if (m->data[0] < level-1) { // Change level level = m->data[0] + 1; timer = 0; } if (m->data[0] == level-1) { // Reset timer timer = 0; } } In message_tx() , we update the message content with the current level just before sending the message : message_t* message_tx() { message.data[0] = level; message.crc = message_crc(&message); return &message; }","title":"Sending and receiving messages"},{"location":"tutorials/tuto4.html#the-loop-function","text":"Every time we enter the loop() , we increase the timer. If it is above TIMEOUT , we decrement the cell's level. The cell will also display different shades from green to red depending on its level. void loop() { // Update timer timer++; if (timer >= TIMEOUT && level < MAX_LEVEL) { // Timeout level++; timer = 0; } // Set light switch (level) { case 1: set_color(RGB(0, 3, 0)); delay(50); break; case 2: set_color(RGB(1, 3, 0)); delay(50); break; case 3: set_color(RGB(3, 3, 0)); delay(50); break; case 4: set_color(RGB(3, 1, 0)); delay(50); break; case MAX_LEVEL: set_color(RGB(3, 0, 0)); delay(50); break; } } Note As the TIMEOUT is set to 30 and the loop() takes 50 milliseconds to execute, a timeout take roughly 1,5 seconds to occur.","title":"The loop() function"},{"location":"tutorials/tuto4.html#put-it-all-together","text":"Don't forget the main() function! int main() { // initialize hardware kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; // start program kilo_start(setup, loop); return 0; }","title":"Put it all together"},{"location":"tutorials/tuto4.html#we-are-done","text":"You can now play with the kilobots, moving them around. Try and see what happens when you change the location of the source kilobot. You can also play around with MAX_LEVEL and TIMEOUT , seeing the effects of each change. If you want to go further, why not make the source/cells move randomly? What happens when you have multiple 'source' kilobots? The possibilities are endless.","title":"We are done !"},{"location":"tutorials/tuto5.html","text":"Rush Hour source code of this tutorial Summary Here we are! This is the last tutorial of this guide. It's now time to wrap up everything we have learnt in one program. In this tutorial, a great number of kilobots will move around randomly. They will communicate with their neighbors, trying to count how many they are. If the kilobot has none or few neighbors, it will turn its LED green . If it has a lot of neighbors on the other hand, it will turn red . The goal is to produce a heat-map of some kind, where red regions correlate with a high kilobot density and green region with a low kilobot density. What you will learn How to use kilo_ticks How to use kilo_uid Summarize everything we have learnt through this guide Probe's program Each kilobot will run the same program : probe.c . The goal of the program is to register up to 5 neighbors and change LED accordingly. Macros Our program will define the following macros : #define TIMEOUT 50 #define MAX_DIST 100 #define MAX_NEIGHBOUR_NB 5 The goal of each macro will be clarified later in this tutorial. kilo_uid and structures During calibration, you can give each kilobot a unique ID . This ID is stored in the kilobot memory and can be accessed via the kilo_uid variable. In this tutorial, we will use it to differentiate every neighbor. Note Be sure to give each kilobot a unique ID at calibration. If two kilobots have the same ID, the final collective behavior will be altered. Each kilobot must also be able to forget a neighbor once it hasn't had contact with it for some time. To do so, we are going to define a structure : struct kilobot { int uid; int timer; }; This C structure stores the neighbor unique ID and the elapsed time since the last contact. To store the information of all neighbors, we can create an array of structures : struct kilobot neighbours[MAX_NEIGHBOUR_NB]; int nb_neighbours = 0; You can easily deduct the role of MAX_NEIGHBOUR_NB : it tells how many neighbors can be stored at the same time. The nb_neighbours variable will be used in two ways at the same time. The first way is to know how many neighbors are registered. The second is to know at which index to write in the neighbours array when registering a new neighbor. (If there are 3 neighbors, the following neighbor must be registered at index 3.) See if a neighbor is already registered When it receives a message, the kilobot must be able to know if it comes from a known neighbor or a new one. If it comes from a known neighbor, it must know at which index to find this neighbor in the neighbours array. This is what this simple algorithm does : int idOfNeighbour(int uid) { /* Looks for kilobot with 'uid' as uid in neighbours. If the kilobot exists, return its index in neighbours. Else, return -1. */ for (int i = 0 ; i < nb_neighbours ; i++) { if (neighbours[i].uid == uid) { return i; } } return -1; } Message and setup() The only data we need to send to our neighbors is our unique ID ( kilo_uid ). We can therefore define the message in setup() , knowing it won't change during the execution. As usual, message_tx() does nothing extraordinary. message_t message; void setup() { // Set message content message.type = NORMAL; message.data[0] = kilo_uid; message.crc = message_crc(&message); } message_t* message_tx() { return &message; } The message_rx() function This function is a bit more complicated. First we must see if the kilobot sending the message is close enough to consider it a neighbor. This is the goal of the MAX_DIST macro : it tells the maximum distance for a kilobot to be considered a neighbor. Then we can use the function we defined previously to know if the kilobot sending the message is already registered in neighbours . If it is not, we register it (assuming we have an available index in neighbours ). If it is, we reset its timer. void message_rx(message_t *m, distance_measurement_t *d) { if (estimate_distance(d) < MAX_DIST) { // The kilobot is close enough int id = idOfNeighbour(m->data[0]); if (id == -1) { // New neighbour, not yet registered if (nb_neighbours < MAX_NEIGHBOUR_NB) { // Can register it neighbours[nb_neighbours].uid = m->data[0]; neighbours[nb_neighbours].timer = 0; nb_neighbours++; } } else { // Neighbour already registered neighbours[id].timer = 0; } } } The loop() function The loop() function has quite a few things to do. First, it increments all of our neighbors' timer . // Increment timer of each kilobot for (int i = 0 ; i < nb_neighbours ; i++) { neighbours[i].timer++; } Second, it checks for neighbors in timeout . This is the goal of the TIMEOUT macro : it tells the limit for a neighbor's timer to be considered too big. If a kilobot is in timeout, we use a simple algorithm to shift all following neighbors to the left in neighbours and decrement nb_neighbours . This way, nb_neighbours still represents the number of neighbors and the index where we can register a new neighbor at the same time. // Check for kilobot timeout for (int i = 0 ; i < nb_neighbours ; i++) { if (neighbours[i].timer >= TIMEOUT) { // Timeout. Remove this kilobot for (int j = i ; j < nb_neighbours-1 ; j++) { neighbours[j] = neighbours[j+1]; } nb_neighbours--; } } Here is where we set the LED to a shade between green and red depending on nb_neighbours : // Set light switch (nb_neighbours) { case 0: set_color(RGB(0, 3, 0)); delay(50); break; case 1: set_color(RGB(1, 3, 0)); delay(50); break; case 2: set_color(RGB(1, 2, 0)); delay(50); break; case 3: set_color(RGB(2, 1, 0)); delay(50); break; case 4: set_color(RGB(3, 1, 0)); delay(50); break; case MAX_NEIGHBOUR_NB: set_color(RGB(3, 0, 0)); delay(50); break; } We still have to make the kilobots move randomly . We want each kilobot to chose a movement between \"straight\", \"turn left\" and \"turn right\" and execute it for one second, every second. We can't really use delay() as it would slow down the loop() considerably, therefore slowing the timers of all neighbors. One solution is to use kilo_ticks . The kilo_ticks variable is used to know the time elapsed since the execution started. It is incremented roughly 32 times per second. By using the % operator, we can then execute a piece of code every second : // Set movement if (kilo_ticks % 32 == 0) { // Roughly every second switch (rand_hard() % 3) { // Choses randomly case 0: // Goes straight spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); break; case 1: // Turn right spinup_motors(); set_motors(0, kilo_turn_right); break; case 2: // Turn left spinup_motors(); set_motors(kilo_turn_left, 0); break; } } Put it all together ! You probably know the main() function by heart at this point. int main() { // initialize hardware kilo_init(); kilo_message_tx = message_tx; kilo_message_rx = message_rx; // start program kilo_start(setup, loop); return 0; } We are done ! This was by far the most complete and complex program of this guide. Congratulations on keeping up to this point. There are still a few minor functionalities of kilobots we have not covered, such as their ability to sense ambient light, measure their board temperature, indicate their voltage or the kilo_message_tx_success callback. You can learn about those in the kilolib documentation . Anyway, we hope this guide was of use. May you have a lot of fun coding for kilobot!","title":"Rush Hour"},{"location":"tutorials/tuto5.html#rush-hour","text":"source code of this tutorial","title":"Rush Hour"},{"location":"tutorials/tuto5.html#summary","text":"Here we are! This is the last tutorial of this guide. It's now time to wrap up everything we have learnt in one program. In this tutorial, a great number of kilobots will move around randomly. They will communicate with their neighbors, trying to count how many they are. If the kilobot has none or few neighbors, it will turn its LED green . If it has a lot of neighbors on the other hand, it will turn red . The goal is to produce a heat-map of some kind, where red regions correlate with a high kilobot density and green region with a low kilobot density.","title":"Summary"},{"location":"tutorials/tuto5.html#what-you-will-learn","text":"How to use kilo_ticks How to use kilo_uid Summarize everything we have learnt through this guide","title":"What you will learn"},{"location":"tutorials/tuto5.html#probes-program","text":"Each kilobot will run the same program : probe.c . The goal of the program is to register up to 5 neighbors and change LED accordingly.","title":"Probe's program"},{"location":"tutorials/tuto5.html#macros","text":"Our program will define the following macros : #define TIMEOUT 50 #define MAX_DIST 100 #define MAX_NEIGHBOUR_NB 5 The goal of each macro will be clarified later in this tutorial.","title":"Macros"},{"location":"tutorials/tuto5.html#kilo_uid-and-structures","text":"During calibration, you can give each kilobot a unique ID . This ID is stored in the kilobot memory and can be accessed via the kilo_uid variable. In this tutorial, we will use it to differentiate every neighbor. Note Be sure to give each kilobot a unique ID at calibration. If two kilobots have the same ID, the final collective behavior will be altered. Each kilobot must also be able to forget a neighbor once it hasn't had contact with it for some time. To do so, we are going to define a structure : struct kilobot { int uid; int timer; }; This C structure stores the neighbor unique ID and the elapsed time since the last contact. To store the information of all neighbors, we can create an array of structures : struct kilobot neighbours[MAX_NEIGHBOUR_NB]; int nb_neighbours = 0; You can easily deduct the role of MAX_NEIGHBOUR_NB : it tells how many neighbors can be stored at the same time. The nb_neighbours variable will be used in two ways at the same time. The first way is to know how many neighbors are registered. The second is to know at which index to write in the neighbours array when registering a new neighbor. (If there are 3 neighbors, the following neighbor must be registered at index 3.)","title":"kilo_uid and structures"},{"location":"tutorials/tuto5.html#see-if-a-neighbor-is-already-registered","text":"When it receives a message, the kilobot must be able to know if it comes from a known neighbor or a new one. If it comes from a known neighbor, it must know at which index to find this neighbor in the neighbours array. This is what this simple algorithm does : int idOfNeighbour(int uid) { /* Looks for kilobot with 'uid' as uid in neighbours. If the kilobot exists, return its index in neighbours. Else, return -1. */ for (int i = 0 ; i < nb_neighbours ; i++) { if (neighbours[i].uid == uid) { return i; } } return -1; }","title":"See if a neighbor is already registered"},{"location":"tutorials/tuto5.html#message-and-setup","text":"The only data we need to send to our neighbors is our unique ID ( kilo_uid ). We can therefore define the message in setup() , knowing it won't change during the execution. As usual, message_tx() does nothing extraordinary. message_t message; void setup() { // Set message content message.type = NORMAL; message.data[0] = kilo_uid; message.crc = message_crc(&message); } message_t* message_tx() { return &message; }","title":"Message and setup()"},{"location":"tutorials/tuto5.html#the-message_rx-function","text":"This function is a bit more complicated. First we must see if the kilobot sending the message is close enough to consider it a neighbor. This is the goal of the MAX_DIST macro : it tells the maximum distance for a kilobot to be considered a neighbor. Then we can use the function we defined previously to know if the kilobot sending the message is already registered in neighbours . If it is not, we register it (assuming we have an available index in neighbours ). If it is, we reset its timer. void message_rx(message_t *m, distance_measurement_t *d) { if (estimate_distance(d) < MAX_DIST) { // The kilobot is close enough int id = idOfNeighbour(m->data[0]); if (id == -1) { // New neighbour, not yet registered if (nb_neighbours < MAX_NEIGHBOUR_NB) { // Can register it neighbours[nb_neighbours].uid = m->data[0]; neighbours[nb_neighbours].timer = 0; nb_neighbours++; } } else { // Neighbour already registered neighbours[id].timer = 0; } } }","title":"The message_rx() function"},{"location":"tutorials/tuto5.html#the-loop-function","text":"The loop() function has quite a few things to do. First, it increments all of our neighbors' timer . // Increment timer of each kilobot for (int i = 0 ; i < nb_neighbours ; i++) { neighbours[i].timer++; } Second, it checks for neighbors in timeout . This is the goal of the TIMEOUT macro : it tells the limit for a neighbor's timer to be considered too big. If a kilobot is in timeout, we use a simple algorithm to shift all following neighbors to the left in neighbours and decrement nb_neighbours . This way, nb_neighbours still represents the number of neighbors and the index where we can register a new neighbor at the same time. // Check for kilobot timeout for (int i = 0 ; i < nb_neighbours ; i++) { if (neighbours[i].timer >= TIMEOUT) { // Timeout. Remove this kilobot for (int j = i ; j < nb_neighbours-1 ; j++) { neighbours[j] = neighbours[j+1]; } nb_neighbours--; } } Here is where we set the LED to a shade between green and red depending on nb_neighbours : // Set light switch (nb_neighbours) { case 0: set_color(RGB(0, 3, 0)); delay(50); break; case 1: set_color(RGB(1, 3, 0)); delay(50); break; case 2: set_color(RGB(1, 2, 0)); delay(50); break; case 3: set_color(RGB(2, 1, 0)); delay(50); break; case 4: set_color(RGB(3, 1, 0)); delay(50); break; case MAX_NEIGHBOUR_NB: set_color(RGB(3, 0, 0)); delay(50); break; } We still have to make the kilobots move randomly . We want each kilobot to chose a movement between \"straight\", \"turn left\" and \"turn right\" and execute it for one second, every second. We can't really use delay() as it would slow down the loop() considerably, therefore slowing the timers of all neighbors. One solution is to use kilo_ticks . The kilo_ticks variable is used to know the time elapsed since the execution started. It is incremented roughly 32 times per second. By using the % operator, we can then execute a piece of code every second : // Set movement if (kilo_ticks % 32 == 0) { // Roughly every second switch (rand_hard() % 3) { // Choses randomly case 0: // Goes straight spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); break; case 1: // Turn right spinup_motors(); set_motors(0, kilo_turn_right); break; case 2: // Turn left spinup_motors(); set_motors(kilo_turn_left, 0); break; } }","title":"The loop() function"},{"location":"tutorials/tuto5.html#put-it-all-together","text":"You probably know the main() function by heart at this point. int main() { // initialize hardware kilo_init(); kilo_message_tx = message_tx; kilo_message_rx = message_rx; // start program kilo_start(setup, loop); return 0; }","title":"Put it all together !"},{"location":"tutorials/tuto5.html#we-are-done","text":"This was by far the most complete and complex program of this guide. Congratulations on keeping up to this point. There are still a few minor functionalities of kilobots we have not covered, such as their ability to sense ambient light, measure their board temperature, indicate their voltage or the kilo_message_tx_success callback. You can learn about those in the kilolib documentation . Anyway, we hope this guide was of use. May you have a lot of fun coding for kilobot!","title":"We are done !"}]}